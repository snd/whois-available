// Generated by CoffeeScript 1.9.3
var containsAny, domainToTld, getAllTlds, getServer, http, httpGet, isSupported, net, punycode, requests, substringsAvailable, substringsNotAvailable, tcpRequest, whoisRequest, whoisServers, whoisServersGenerated, whoisServersPatches;

net = require('net');

http = require('http');

punycode = require('punycode');

whoisServersGenerated = require('./data/whois-servers-generated');

whoisServersPatches = require('./data/whois-servers-patches');

requests = require('./data/requests');

substringsAvailable = require('./data/substrings-available');

substringsNotAvailable = require('./data/substrings-not-available');

whoisServers = {};

Object.keys(whoisServersGenerated).forEach(function(tld) {
  if (whoisServersPatches[tld] !== null) {
    return whoisServers[tld] = whoisServersGenerated[tld];
  }
});

Object.keys(whoisServersPatches).forEach(function(tld) {
  if (whoisServersPatches[tld] !== null) {
    return whoisServers[tld] = whoisServersPatches[tld];
  }
});

tcpRequest = function(port, hostname, request, cb) {
  var cbCalled, response, socket, timeoutSeconds;
  socket = net.createConnection(port, hostname);
  socket.setEncoding('utf8');
  timeoutSeconds = 20;
  socket.setTimeout(timeoutSeconds * 1000);
  socket.on('connect', function() {
    return socket.write(request);
  });
  response = '';
  cbCalled = false;
  socket.on('data', function(data) {
    return response += data;
  });
  socket.on('error', function(error) {
    if (!cbCalled) {
      cb(error);
    }
    return cbCalled = true;
  });
  socket.on('timeout', function() {
    socket.end();
    if (!cbCalled) {
      cb(new Error("request to " + hostname + ":" + port + " timed out"));
    }
    return cbCalled = true;
  });
  return socket.on('close', function(hadError) {
    if (!cbCalled) {
      cb(null, response);
    }
    return cbCalled = true;
  });
};

whoisRequest = function(whoisServer, request, cb) {
  return tcpRequest(43, whoisServer, request + "\r\n", cb);
};

httpGet = function(url, cb) {
  return http.get(url, function(res) {
    var body;
    body = '';
    res.on('data', function(data) {
      return body += data;
    });
    return res.on('end', function() {
      return cb(null, res, body);
    });
  }).on('error', function(err) {
    return cb(err);
  });
};

getAllTlds = function(cb) {
  return httpGet('http://data.iana.org/TLD/tlds-alpha-by-domain.txt', function(err, res, body) {
    var domains;
    if (err != null) {
      cb(err);
      return;
    }
    if (res.statusCode !== 200) {
      cb(new Error("response status code wasn't 200 but " + res.statusCode + " instead"));
      return;
    }
    domains = body.split('\n').map(function(x) {
      return x.trim().toLowerCase();
    }).filter(function(x) {
      return 0 !== x.indexOf('#');
    }).filter(function(x) {
      return x !== '';
    });
    return cb(null, domains);
  });
};

domainToTld = function(domain) {
  var domainParts, domainPunycode;
  domainPunycode = punycode.toASCII(domain);
  domainParts = domainPunycode.split('.');
  return domainParts[domainParts.length - 1];
};

getServer = function(domain, cb) {
  return whoisRequest('whois.iana.org', domainToTld(domain), function(err, result) {
    var match;
    if (err != null) {
      cb(err);
      return;
    }
    match = /whois:\s+(\S+)/.exec(result);
    if ((match != null ? match[1] : void 0) == null) {
      cb();
      return;
    }
    return cb(null, match[1]);
  });
};

containsAny = function(array, string) {
  var index, length;
  index = -1;
  length = array.length;
  while (++index < length) {
    if (-1 !== string.indexOf(array[index])) {
      return array[index];
    }
  }
};

isSupported = function(domain) {
  return whoisServers[domainToTld(domain)] != null;
};

module.exports = function(domain, cb) {
  var domainParts, domainPunycode, domainToRequest, request, server, tld;
  if (domain === '') {
    process.nextTick(function() {
      return cb(new Error('domain must not be empty'));
    });
    return;
  }
  domainPunycode = punycode.toASCII(domain);
  domainParts = domainPunycode.split('.');
  tld = domainParts[domainParts.length - 1];
  server = whoisServers[tld];
  if (server == null) {
    process.nextTick(function() {
      return cb(new Error("no known whois server for tld " + tld + ". read xxx on how to add one"));
    });
    return;
  }
  domainToRequest = requests[server] || function(x) {
    return x;
  };
  request = domainToRequest(domainPunycode);
  return whoisRequest(server, request, function(err, response) {
    var availableBecauseResponseContained, butNotAvailableBecauseResponseContained;
    if (err != null) {
      cb(err);
      return;
    }
    availableBecauseResponseContained = containsAny(substringsAvailable, response);
    if (availableBecauseResponseContained != null) {
      butNotAvailableBecauseResponseContained = containsAny(substringsNotAvailable, response);
    }
    return cb(null, {
      isAvailable: (availableBecauseResponseContained != null) && (butNotAvailableBecauseResponseContained == null),
      domain: domain,
      punycode: domainPunycode,
      tld: tld,
      response: response,
      availableBecauseResponseContained: availableBecauseResponseContained,
      butNotAvailableBecauseResponseContained: butNotAvailableBecauseResponseContained,
      server: server,
      request: request
    });
  });
};

module.exports.domainToTld = domainToTld;

module.exports.getServer = getServer;

module.exports.getAllTlds = getAllTlds;

module.exports.isSupported = isSupported;

module.exports.tlds = Object.keys(whoisServers);

module.exports.whoisServers = whoisServers;
